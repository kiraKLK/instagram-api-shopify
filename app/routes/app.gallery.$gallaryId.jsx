import { useState, useCallback, useEffect, useRef, useMemo } from 'react';
import {
    InlineGrid,
    Text,
    InlineStack,
    Page,
    Box,
    Divider,
    Card,
    Scrollable,
    BlockStack,
    TextField,
    Checkbox,
    Icon,
    Modal,
    Pagination,
    Button,
    ChoiceList
} from '@shopify/polaris';
import { Modal as ModalIframe, TitleBar, useAppBridge, SaveBar } from '@shopify/app-bridge-react';
import {
    SearchIcon, DeleteIcon
} from '@shopify/polaris-icons';
import { json } from "@remix-run/node";
import styles from '../style/style-gallery.css?url'
import { useLoaderData, useFetcher, useParams } from "@remix-run/react";
import axios from 'axios';
import db from "../db.server";
import { authenticate } from "../shopify.server";
import GalleryTest from '../component/gallery';

export const links = () => [{ rel: "stylesheet", href: styles }];

export async function loader({ request, params }) {
    const { admin, session } = await authenticate.admin(request);
    const galleryId = params.gallaryId; // L·∫•y gi√° tr·ªã t·ª´ params
    const gallerys = await db.gallery.findFirst({
        where: {
            id: parseInt(galleryId, 10) // S·ª≠ d·ª•ng gi√° tr·ªã t·ª´ params
        }
    });
    const sourceByGalleryId = await db.source.findFirst({
        where: {
            id: gallerys.sourceId
        }
    })
    const account = await db.account.findFirst({
        where: { id: sourceByGalleryId.accountId },
    });

    const accessToken = account?.accessToken;
    if (accessToken) {
        try {
            const response = await axios.get('https://graph.instagram.com/me', {
                params: {
                    fields: 'profile_picture_url,username,media{caption,media_type,media_url,comments_count,like_count,timestamp}',
                    access_token: accessToken
                }
            });

            const posts = response?.data;
            const responseProducts = await admin.graphql(
                `#graphql
                query {
                    products (first: 50, query: "status:active AND published_status:published") {
                        nodes {
                        id
                        title
                        handle
                        images(first: 1) {
                            edges {
                            node {
                                src
                            }
                            }
                        }
                        variants(first: 1) {
                            edges {
                            node {
                                price
                            }
                            }
                        }
                        }
                    }
                }`,
            );

            const data = await responseProducts.json();
            const products = data.data.products;

            const sources = await db.source.findMany({})

            return json({ posts, products, gallerys, source: sourceByGalleryId, sources });
        } catch (error) {
            console.error('L·ªói khi l·∫•y b√†i vi·∫øt:', error.response?.data || error.message);
            throw error;
        }
    }
    return null;
}

export const action = async ({ request, params }) => {
    try {
        // X√°c th·ª±c admin v√† session
        const { admin, session } = await authenticate.admin(request);

        // Chuy·ªÉn ƒë·ªïi formData th√†nh ƒë·ªëi t∆∞·ª£ng
        const formData = Object.fromEntries(await request.formData());
        const actionType = formData._action;
        // L·∫•y d·ªØ li·ªáu t·ª´ formData
        const galleryName = formData?.galleryName?.toString() ?? ""
        const sourceName = formData?.sourceName?.toString() ?? ""
        console.log("üöÄ ~ action ~ galleryName:", galleryName)
        const taggedProducts = formData?.taggedProducts?.toString() ?? "";

        // const metafield = new admin.rest.resources.Metafield({ session });
        // //G√°n namespace, key v√† value cho Metafield
        // metafield.namespace = "instagram";
        // metafield.key = "gallery";
        // metafield.value = JSON.stringify({
        //     taggedProducts
        // });
        // metafield.type = "json";
        // // L∆∞u Metafield m·ªõi
        // await metafield.save({ update: true })
        switch (actionType) {
            case "update": {
                const galleryId = params.gallaryId; // L·∫•y gi√° tr·ªã t·ª´ params
                const gallerys = await db.gallery.findFirst({
                    where: {
                        id: parseInt(galleryId, 10) // S·ª≠ d·ª•ng gi√° tr·ªã t·ª´ params
                    }
                });

                await db.gallery.update({
                    where: { id: gallerys.id }, // üîπ Thay id n√†y b·∫±ng gi√° tr·ªã ph√π h·ª£p (v√≠ d·ª•: postId, userId, ...)
                    data: {
                        taggerProducts: taggedProducts, // C·∫≠p nh·∫≠t d·ªØ li·ªáu n·∫øu t·ªìn t·∫°i
                        galleyName: galleryName,
                        sourceId: gallerys.sourceId,
                    },
                });
                return json({
                    success: true,
                    message: "Update gallery successfully.",
                }, { status: 200 });
            }
            case "selectBySourceName": {
                const source = await db.source.findFirst({
                    where: { sourceName: sourceName },
                })
                const account = await db.account.findFirst({
                    where: { id: source.accountId }
                })
                const accessToken = account?.accessToken
                const response = await axios.get('https://graph.instagram.com/me', {
                    params: {
                        fields: 'profile_picture_url,username,media{caption,media_type,media_url,comments_count,like_count,timestamp}',
                        access_token: accessToken
                    }
                });

                const posts = response?.data;
                return Response.json({
                    success: true,
                    message: `Select source successfully.`,
                    posts,
                    source: source.sourceName
                });
            }
            default:
                return json({ error: "Unknown action type." }, { status: 400 });
        }
    } catch (error) {
        console.error("Cannot load database!", error);
        return json({ error: "Internal server error." }, { status: 500 });
    }
}

export function shouldRevalidate() {
    return true;
}


export default function Source() {
    const fetcher = useFetcher()
    const shopify = useAppBridge()
    const loaderData = useLoaderData(); //L·∫•y data t·ª´ loader
    const params = useParams(); // Declare params to use in the component
    const [posts, setPost] = useState(loaderData?.posts || [])
    const productsLoader = loaderData?.products || [] // Data t·∫•t c·∫£ s·∫£n ph·∫©m trong store
    const gallery = loaderData?.gallerys || {}
    const source = loaderData?.source || {}
    const sources = loaderData?.sources || []
    const [createView, setCreateView] = useState(false);
    const [currentPost, setCurrentPost] = useState(null) //L∆∞u b√†i vi·∫øt hi·ªán t·∫°i ƒë·ªÉ hi·ªÉn th·ªã l√™n modal
    const [taggedProducts, setTaggedProducts] = useState(JSON.parse(gallery?.taggerProducts || "{}")); //L∆∞u ƒë·ªëi t∆∞·ª£ng ch·ª©a th√¥ng tin tag theo t·ª´ng post
    const [currentIndex, setCurrentIndex] = useState(0); // Ch·ªâ m·ª•c b√†i vi·∫øt hi·ªán t·∫°i
    const [checked, setChecked] = useState(false); // Check ch·ªçn t·∫•t c·∫£ b√†i vi·∫øt
    const handleChangeCheck = useCallback(
        (newChecked) => setChecked(newChecked),
        [],
    )
    const [active, setActive] = useState(false); //Toggele b·∫≠t t·∫Øt modal
    const [activePreviewModal, setActivePreviewModal] = useState(false); //Toggele b·∫≠t t·∫Øt preview
    const handleTogglePreviewModal = useCallback((post) => {
        setActivePreviewModal(!activePreviewModal); // ‚úÖ C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë√∫ng c√°ch
        setCurrentPost(prevPost => (prevPost?.id === post.id ? prevPost : post)); // ‚úÖ Ch·ªâ c·∫≠p nh·∫≠t n·∫øu kh√°c
    }, [activePreviewModal]); // ‚úÖ Kh√¥ng c·∫ßn dependency ƒë·ªÉ tr√°nh re-render v√¥ t·∫≠n

    const toggleModal = useCallback(() => setActive((active) => !active), []);
    const handleChanges = useCallback((post) => {
        setActive(!active)
        setCurrentPost(prevPost => (prevPost?.id === post.id ? prevPost : post)); // ‚úÖ Ch·ªâ c·∫≠p nh·∫≠t n·∫øu kh√°c
    }, [active])
    //T·∫Øt loading khi rendered component
    useEffect(() => {
        shopify.loading(false)
    }, [shopify]);

    const [showError, setShowError] = useState({});
    const [galleryName, setGalleryName] = useState(gallery?.galleyName);
    const handleSourceNameChange = useCallback(
        (value) => {
            setGalleryName(value);
            if (value !== "") setShowError({ error: false, message: "" });
            if (value === "") setShowError({ error: true, message: "Gallery name is required" });
        },
        []
    );
    const validataForm = (sourceName, accountName) => {
        if (sourceName === "") setShowError({ error: true, message: "Gallery name is required" });
        if (checkSameName(sourceName)) setShowError({ error: true, message: "Gallery name is already exists" });
        if (accountName.length === 0) setShowErrorAccount({ error: true, message: "Select source is required" });
        return sourceName !== "" && accountName.length > 0 && !checkSameName(sourceName);
    };

    const checkSameName = (sourceName) => {
        return source.sourceName === sourceName
    }
    //Ch·ªçn account t·∫°o source
    // State ƒë·ªÉ l∆∞u tr·∫°ng th√°i ch·ªçn c·ªßa t·ª´ng t√†i kho·∫£n
    const [showErrorAccount, setShowErrorAccount] = useState({});
    const [selectedSources, setSelectedSources] = useState([source.sourceName]);
    // X·ª≠ l√Ω khi thay ƒë·ªïi gi√° tr·ªã ChoiceList
    const handleChange = useCallback((value) => {
        if (value !== selectedSources) {
            setSelectedSources(value);
            if (value.length > 0) setShowErrorAccount({ error: false, message: "" });
            if (showErrorAccount.length === 0) setShowErrorAccount({ error: true, message: "Select source is required" });
        }
    }, [selectedSources, showErrorAccount]);
    const handleSelectSource = async (sourceName) => {
        try {
            const formData = new FormData();
            formData.append("_action", "selectBySourceName");
            formData.append("sourceName", sourceName);
            await fetcher.submit(formData, { method: "post" });
            shopify.loading(true)
        } catch (error) {
            console.error("Error deleting account:", error);
        }
    }
    const handleRemoveSource = useCallback(() => {
        setSelectedSources([]);
        setPost({ ...posts, media: { ...posts.media, data: [] } });
    }, [posts]);

    const handleSave = async () => {
        try {
            // Thu th·∫≠p d·ªØ li·ªáu t·ª´ c√°c tr·∫°ng th√°i
            const actionType = "update"; // Ho·∫∑c b·∫•t k·ª≥ h√†nh ƒë·ªông n√†o b·∫°n c·∫ßn
            const formData = {
                galleryName: galleryName,
                sourceName: selectedSources[0],
                taggedProducts: JSON.stringify(taggedProducts), // Chuy·ªÉn object th√†nh JSON string
                _action: actionType,
            }
            console.log("üöÄ ~ handleSave ~ formData:", formData)
            // G·ª≠i d·ªØ li·ªáu t·ªõi server
            await fetcher.submit(formData, { method: "post" });
            shopify.loading(true)

        } catch (error) {
            console.error("Error save database:", error);
            console.log("Cannot save!");
        } finally {
            console.log();
        }
    }
    const hasChanges = useMemo(() => {
        return (

            galleryName !== gallery?.galleyName ||
            !selectedSources.includes(source?.sourceName) ||
            JSON.stringify(taggedProducts) !== JSON.stringify(JSON.parse(gallery?.taggerProducts || "{}"))
        )

    }, [galleryName, selectedSources, taggedProducts]);

    const [unSave, setUnSave] = useState()
    useEffect(() => {
        if (hasChanges) {
            console.log("üöÄ ~ hasChanges ~ galleryName:", galleryName)
            console.log("üöÄ ~ hasChanges ~ gallery?.galleyName:", gallery?.galleyName)
            console.log("üöÄ ~ Source ~ gallery:", gallery)
            setUnSave(true)
            shopify.saveBar.show('my-save-bar');
        } else {
            setUnSave(false)
            shopify.saveBar.hide('my-save-bar');
        }
    }, [hasChanges, shopify, taggedProducts, selectedSources, galleryName]);

    useEffect(() => {
        if (fetcher.state === "loading") {
            shopify.toast.show(fetcher.data?.message, {
                duration: 2500,
            });
            switch (fetcher.data?.message) {
                case "Select source successfully.": {
                    shopify.modal.hide('my-modal');
                    setPost(fetcher.data?.posts);
                    setSelectedSources(fetcher.data?.source);
                    break;
                }
                case "Update gallery successfully.": {
                    shopify.saveBar.hide('my-save-bar')
                }
                default:
                    break;
            }
            shopify.loading(false); // t·∫Øt loading
        }
    }, [fetcher.data?.message, fetcher.state, shopify, params.gallaryId]);
    //const [selectedProducts, setSelectedProducts] = useState([]); //L∆∞u danh s√°ch s·∫£n ph·∫©m ƒë∆∞·ª£c tag v√† v·ªã tr√≠ tag
    const selectedProducts = useMemo(() => taggedProducts[currentPost?.id] || [], [currentPost, taggedProducts]);
    const [imageClickPosition, setImageClickPosition] = useState(null);// L∆∞u v·ªã tr√≠ ch·ªçn tag
    const [cursorPosition, setCursorPosition] = useState(null); //L∆∞u v·ªã tr√≠ ch·ªØ ƒëi theo con tr·ªè chu·ªôt
    const [hideCursorText, setHideCursorText] = useState(false); //L∆∞u tr·∫°ng th√°i hi·ªÉn th·ªã c·ªßa ch·ªØ ƒëi theo con tr·ªè chu·ªôt 
    const [textFieldSearchProducts, setTextFieldSearchProducts] = useState(""); //X·ª≠ l√Ω input search s·∫£n ph·∫©m
    const handleTextFieldSearchChange = useCallback(
        (value) => setTextFieldSearchProducts(value),
        [],
    );

    //X·ª≠ l√Ω chi·ªÅu d√†i c·ªßa popover
    const [popoverWidths, setPopoverWidths] = useState({});
    const popoverRefs = useRef({});
    useEffect(() => {
        if (selectedProducts.length === Object.keys(popoverWidths).length) return;
        const newWidths = {};
        Object.keys(popoverRefs.current).forEach((key) => {
            if (popoverRefs.current[key]) {
                newWidths[key] = popoverRefs.current[key].offsetWidth;
            }
        });
        setPopoverWidths(newWidths);
    }, [selectedProducts]); // ‚úÖ Lo·∫°i b·ªè popoverWidths kh·ªèi dependency
    const handleImageClick = (event) => {
        const img = event.target; // ·∫¢nh m√† user click v√†o
        const rect = img.getBoundingClientRect();

        const x = event.clientX - rect.left; // Pixel position inside the image
        const y = event.clientY - rect.top;

        // Chuy·ªÉn t·ªça ƒë·ªô pixel th√†nh ph·∫ßn trƒÉm v√† l√†m tr√≤n ƒë·∫øn 4 ch·ªØ s·ªë th·∫≠p ph√¢n
        const xPercent = ((x / rect.width) * 100)

        const yPercent = ((y / rect.height) * 100)

        // L∆∞u v·ªã tr√≠ theo ph·∫ßn trƒÉm
        setImageClickPosition({ x: xPercent, y: yPercent });

        // Hi·ªÉn th·ªã modal ch·ªçn s·∫£n ph·∫©m
        shopify.modal.show('modal-list-producst');
    };
    //X·ª≠ l√Ω di chuy·ªÉn chu·ªôt trong ·∫£nh
    const handleMouseMove = (event) => {
        if (hideCursorText) return; // N·∫øu chu·ªôt ƒëang ·ªü dot ho·∫∑c popover, kh√¥ng hi·ªÉn th·ªã cursor-text
        const rect = event.target.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        setCursorPosition({ x, y });
    };
    //X·ª≠ l√Ω khi r·ªùi chu·ªôt kh·ªèi ·∫£nh
    const handleMouseLeave = () => {
        setCursorPosition(null);
    };
    //X·ª≠ l√Ω ch·ªçn s·∫£n ph·∫©m trong modal
    const handleSelectProduct = (product) => {
        //setSelectedProducts([...selectedProducts, { ...product, position: imageClickPosition }]);
        if (!currentPost) return;

        setTaggedProducts((prev) => {
            const postId = currentPost.id;
            const updatedProducts = [...(prev[postId] || []), { ...product, position: imageClickPosition }];

            if (JSON.stringify(prev[postId]) === JSON.stringify(updatedProducts)) {
                return prev; // Tr·∫£ v·ªÅ state c≈© n·∫øu kh√¥ng c√≥ thay ƒë·ªïi th·ª±c s·ª±
            }

            return {
                ...prev,
                [postId]: updatedProducts,
            };
        });

        shopify.modal.hide('modal-list-producst')
    };
    //X·ª≠ l√Ω hi·ªÉn th·ªã popover khi hover v√†o dot
    const getPopupPosition = (dotX, dotY, popWidth) => {

        const popupWidth = popWidth;  // Chi·ªÅu r·ªông c·ªßa popup
        const popupHeight = 80;  // Chi·ªÅu cao c·ªßa popup
        const offset = 10;       // Kho·∫£ng c√°ch gi·ªØa dot v√† popup
        const imgWidth = 400;    // Chi·ªÅu r·ªông c·ªßa ·∫£nh
        const imgHeight = 400;   // Chi·ªÅu cao c·ªßa ·∫£nh
        let left = popupWidth / 2;
        let top = 2;
        let arrow = null;
        //C√°c v·ªã tr√≠ c·∫ßn ch·ªânh s·ª≠a
        //tr√°i -> dotX < popupWidth / 2; 
        if (dotX < popupWidth / 2) {
            left = 0
            top = 2
            arrow = 1
        }
        //ph·∫£i -> imgWidth - popupWidth / 2;
        if (dotX > (imgWidth - popupWidth / 2)) {
            left = popupWidth - 4
            top = 2
            arrow = popupWidth - 26
        }
        //d∆∞·ªõi -> imgHeight - popupHeight
        if (dotY > (imgHeight - popupHeight)) { top = -80 }
        return { left, top, arrow };
    };

    //L·ªçc danh s√°ch s·∫£n ph·∫©m d·ª±a tr√™n t·ª´ kh√≥a t√¨m ki·∫øm
    const filteredProducts = useMemo(() => {
        const searchTerm = textFieldSearchProducts?.toLowerCase().trim();
        return productsLoader.nodes.filter((product) =>
            product.title.toLowerCase().includes(searchTerm)
        );
    }, [textFieldSearchProducts, productsLoader]);
    //X·ª≠ l√Ω hover v√†o item
    const [hoveredProductId, setHoveredProductId] = useState(null);
    //X·ª≠ l√Ω x√≥a item tag kh·ªèi danh s√°ch ch·ªçn
    const handleRemoveProduct = (productId) => {
        //setSelectedProducts((prevProducts) => prevProducts.filter((item) => item.id !== productId));
        if (!currentPost) return;

        setTaggedProducts((prev) => {
            const postId = currentPost.id;
            const updatedProducts = prev[postId]?.filter((item) => item.id !== productId) || [];

            return {
                ...prev,
                [postId]: updatedProducts,
            };
        });
    };
    //
    const handleNextPost = () => {
        if (currentIndex < posts.media.data.length - 1) {
            const newIndex = currentIndex + 1;
            setCurrentIndex(newIndex);
            setCurrentPost(posts.media.data[newIndex]);
        }
    };

    const handlePreviousPost = () => {
        if (currentIndex > 0) {
            const newIndex = currentIndex - 1;
            setCurrentIndex(newIndex);
            setCurrentPost(posts.media.data[newIndex]);
        }
    };

    return (
        <>
            <GalleryTest
                posts={posts}
                products={productsLoader}
                currentPost={currentPost}
                taggedProducts={taggedProducts}
                handleImageClick={handleImageClick}
                handleMouseMove={handleMouseMove}
                handleMouseLeave={handleMouseLeave}
                handleSelectProduct={handleSelectProduct}
                handleRemoveProduct={handleRemoveProduct}
                handleNextPost={handleNextPost}
                handlePreviousPost={handlePreviousPost}
                toggleModal={toggleModal}
                active={active}
                activePreviewModal={activePreviewModal}
                handleTogglePreviewModal={handleTogglePreviewModal}
                handleChange={handleChanges}
                checked={checked}
                handleChangeCheck={handleChangeCheck}
                textFieldSearchProducts={textFieldSearchProducts}
                handleTextFieldSearchChange={handleTextFieldSearchChange}
                filteredProducts={filteredProducts}
                hoveredProductId={hoveredProductId}
                setHoveredProductId={setHoveredProductId}
                popoverWidths={popoverWidths}
                popoverRefs={popoverRefs}
                getPopupPosition={getPopupPosition}
                cursorPosition={cursorPosition}
                hideCursorText={hideCursorText}
                setHideCursorText={setHideCursorText}
                handleSave={handleSave}
                fetcher={fetcher}
                selectedProducts={selectedProducts}
                isAddGallery={false}
                showError={showError}
                handleSourceNameChange={handleSourceNameChange}
                galleryName={galleryName}
                setGalleryName={setGalleryName}
                selectedSources={selectedSources}
                shopify={shopify}
                showErrorAccount={showErrorAccount}
                handleRemoveSource={handleRemoveSource}
                setCreateView={setCreateView}
                hasChanges={unSave}
            />
            <SaveBar id="my-save-bar">
                <button
                    // loading={fetcher.state === "submitting" ? "true" : undefined}
                    loading={fetcher.state === "submitting" ? "true" : false}
                    variant="primary"
                    onClick={(e) => {
                        if (validataForm(galleryName, selectedSources)) {
                            handleSave();
                            setUnSave(false)
                        }
                        else {
                            shopify.saveBar.leaveConfirmation()
                            e.preventDefault()
                        }
                    }}
                >
                    Save source
                </button>
                <button
                    onClick={() => {
                        shopify.saveBar.hide('my-save-bar');
                        setUnSave(false)
                    }}
                >
                    Discard
                </button>
            </SaveBar>
            <ModalIframe onHide={() => setSelectedSources([])} id="my-modal">
                <BlockStack>
                    <Box padding='400' background="bg-surface" borderRadius="100">
                        <Card>
                            <BlockStack gap='200'>

                                <BlockStack gap='200'>
                                    <Text variant="bodyMd" as="p">
                                        Select source
                                    </Text>
                                    {sources.length > 0 ?
                                        (
                                            <InlineGrid gap='100' columns={2}>
                                                {sources.map((ga, index) => (
                                                    <Box key={index} borderStyle='solid' borderRadius="200" borderWidth='25' padding='200'>
                                                        <InlineStack align='space-between'>
                                                            <InlineStack gap='200' blockAlign='center'>
                                                                <div className='item-select-profile-name'>I</div>
                                                                <div className='item-select-profile-username'>{ga.sourceName}</div>
                                                            </InlineStack>
                                                            <ChoiceList
                                                                choices={[
                                                                    { label: '', value: ga.sourceName },
                                                                ]}
                                                                selected={selectedSources}
                                                                onChange={(value) => handleChange(value)}
                                                            />
                                                        </InlineStack>
                                                    </Box>
                                                ))}
                                            </InlineGrid>
                                        ) : (
                                            <InlineStack blockAlign='center' align="space-between">
                                                <InlineStack>

                                                    <div>Connect your Instagram account first.</div>
                                                </InlineStack>
                                                <Button onClick={() => window.open(url, "_parent")} variant="primary">Connect</Button>
                                            </InlineStack>
                                        )
                                    }
                                </BlockStack>

                            </BlockStack>
                        </Card>
                    </Box>
                </BlockStack>
                <TitleBar title="Select media source">
                    <button
                        onClick={() => { handleSelectSource(selectedSources[0]); shopify.modal.hide('my-modal') }}
                        disabled={selectedSources.length === 0}
                        variant="primary"
                        loading={fetcher.state === "submitting" ? "true" : undefined}
                    >
                        Ok
                    </button>
                    <button onClick={() => shopify.modal.hide('my-modal')}>Cancel</button>
                </TitleBar>
            </ModalIframe>
        </>
    )
}


